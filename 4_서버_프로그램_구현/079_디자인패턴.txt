디자인 패턴(Design Pattern)
- 모듈 간 관계 및 인터페이스를 설계할 때 참조할 수 있는 전형적인 해결 방식 또는 예제
- 문제 및 배경, 실제 적용된 사례, 재사용이 가능한 샘플 코드 등으로 구성
- 개발 과정 중 문제가 발생하면 새로 해결책을 구상하는 것보다 문제에 해당하는 디자인 패턴 참고해 적용하는게 효율적
- GOF의 디자인 패턴은 생성패턴, 구조패턴, 행위패턴으로 구분

생성 패턴(Creational Pattern) 
- 클래스나 객체의 생성과 참조 과정 정의
- 추상 팩토리(Abstract Factory) : 구체적 클래스에 의존하지 않고 인터페이스를 통해 서로 연관, 의존하는 객체들의 그룹으로 생성해 추상적으로 표현
                                       : 연관된 서브 클래스를 묶어 한번에 교체 가능
                                       : 즉 서로 다른 부품을 조립만 하는 조립공장
- 빌더(Builder) : 작게 분리된 인스턴스를 건축 하듯 조합해 객체 생성
                  : 객체의 생성 과정과 표현 방법을 분리하고 있어 동일한 객체 생성에서도 서로 다른 결과 만들어 냄
- 팩토리 메소드(Feactory Method) = 가상 생성자 패턴 : 객체 생성을 서브 클래스에서 처리하도록 분리해 캡슐화
                                                                   : 상위 클래스에서 인터페이스만 정의하고 실제 생성은 서브 클래스가 담당. 즉 부품부터 완성품까지 통째로 찍어내는 공장
- 프로토타입(Prototype) : 원본 객체를 복제하는 방법으로 객체 생성. 즉 원형을 두고 복제품을 만듦
                              : 일반적인 방법으로 객체 생성, 비용이 큰 경우 주로 이용
- 싱글톤(Singleton) : 하나의 객체를 생성하면 생성된 객체를 어디서든 참조가능, 그러나 여러 프로세스가 동시에 참조 불가능. 즉 정수기 하나뿐이지만 누구나 사용 가능
                        : 클래스 내에서 인스턴스가 하나뿐임을 보장, 불필요한 메모리 낭비 최소화

구조 패턴(Structural Pattern)
- 클래스나 객체들을 조합해 더 큰 구조로 만드는 패턴 -> 복잡한 시스템 개발하기 쉽도록
- 어댑터(Adapter) : 호환성이 없는 클래스들의 인터페이스를 다른 클래스가 이용할 수 있도록 변환. 즉 변압기
                       : 기존의 클래스 이용하고 싶지만 인터페이스가 일치하지 않을때 이용
- 브리지(Bridge) : 구현부에서 추상층 분리해 서로가 독립적으로 확장할 수 있도록 구성. 즉 두 섬을 연결하는 다리
                     : 기능과 구현을 두 개의 별도 클래스로 구현
- 컴포지트(Composite) : 여러 객체를 가진 복합 객체와 단일 객체를 구분 없이 다루고자 할 때 사용. 즉 폴더와 파일 합성
                             : 객체들을 트리구조로 구성해 디렉터리 안에 디렉터리가 있듯 복합 개체 안에 복합 객체가 포함되는 구조 구현 가능
- 데코레이터(Decorator) : 객체간 결합 통해 능동적으로 기능 확장 가능
                               : 임의의 객체에 부가적 기능 추가위해 다른 객체들 덧붙이는 방식으로 구현
- 퍼싸드(Facade) : 복잡한 서브 클래스들을 피해 더 상위에 인터페이서 구성해 서브 클래스들의 기능을 간편하게 사용 가능. 즉 버튼만으로 복잡한 명령 간편하게 수행하는 외부의 리모컨
                      : 서브 클래스들 사이의 통합 인터페이스 제공하는 Wrapper 객체 필요
- 플라이웨이트(Flyweight) : 인스턴스가 필요할 때마다 매번 생성하는 것이 아닌 가능한한 공유해 사용해 메모리 절약. 즉 부담 가볍게 하기 위해 공유
                                 : 다수의 유사 객체 생성하거나 조작할때 유용
- 프록시(Proxy) : 접근이 어려운 객체와 여기에 연결하려는 객체 사이에서 인터페이스 역할 수행. 즉 내가 하기 어려운 업무 대리
                    : 네트워크 연결, 메모리의 대용량 객체로의 접근 등에 주로 이용

행위 패턴(Behaviral Pattern)
- 클래스나 객체들이 서로 상호작용하는 방법이나 책입 분배 방법을 정의
- 책임 연쇄(Chain of Reponsibility) : 요청을 처리할 수 있는 객체가 둘 이상 존재하여 한 객체가 처리 못하면 다음 객체로 넘어감
                                           : 요청을 처리할 수 있는 각 개체가 체인으로 묶여 요청이 해결될 때까지 고리를 따라 책임감 넘어감. 즉 의리게임 생각
- 커맨드(Command) : 요청을 객체의 형태로 캡슐화해 재이용, 취소 가능하도록 요청에 필요한 정보를 저장하거나 로그에 남김. 즉 각종 멸령어 하나로 합쳐둠
                          : 요청에 사용되는 각종 멸령어들을 추상 클래스와 구체 클래스로 분리해 단순화
- 인터프리터(Interpreter) : 언어에 문법 표현 정의, SQL이나 통신 프로토콜과 같은 것 개발할 때 사용
- 반복자(Iterator) : 자료구조와 같이 접근이 잦은 객체에 대해 동일한 인터페이스 사용. 즉 같은 명령 반복
                      : 내부 표현 방법의 노출 없이 순차적 접근 가능
- 중재자(Mediator) : 수많은 객체들 간 복잡한 상요작용 캡슐화해 객체로 정의. 즉 물품 매매 중개해주는 인터넷 사이트
                         : 객체 사이의 의존성 줄여 결합도 감소
- 메멘토(Memento) : 특정 시점에서의 객체 내부 상태를 객체화해 이후 요청에 따라 객체를 해당 시점의 상태로 돌릴 수 있는 기능 제공
                         : ctril+z와 같은 되돌리기 기능 개발할 때 주로 이용
- 옵서버(Observer) : 한 객체의 상태가 변화하면 객체에 상속되어 있는 다른 객체들에게 변화된 상태 전달. 즉 변화를 지켜보고 알려줌
                        : 일대다의 의존성 정의, 주로 분산된 시스템 간 이벤트 생성, 발행하고 이를 수신해야할 때 이용
- 상태(State) : 객체의 상태에 따라 동일한 동작 다르게 처리해야할 때 사용
                 : 객체 상태를 캡슐화하고 이를 참조하는 방식으로 처리
- 전략(Strategy) : 동일한 계열의 알고리즘들 개별적으로 캡슐화해 상호 교환 가능. 즉 전략을 만들어 선택
                     : 클라이언트는 독립적으로 원하는 알고리즘 선택해 사용가능, 클라이언트에 영향 없이 알고리즘 변경 가능.
- 템플릿 메소드(Template Method) : 상위 클래스에서 골격 정의, 하위 클래스에서 세부처리 구체화
                                            : 유사한 서브 클래스 묶어 공통된 내용을 상위 클래스에서 정의해 코드의 양 줄이고 유지보수 용이
- 방문자(Visitor) : 각 클래스들의 데이터 구조에서 처리 기능을 분리해 별도의 클래스로 구성
                     : 분리된 처리 기능은 각 클래스를 방문하여 수행